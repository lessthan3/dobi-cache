// Generated by CoffeeScript 1.12.7
(function() {
  var MongoCache, exports,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MongoCache = require('dobi-mongo-cache');

  module.exports = exports = function(config) {
    var cache;
    if (config.disabled == null) {
      config.disabled = false;
    }
    cache = new MongoCache(config.mongo);
    return function(options, fn) {
      var age, ref, ref1, type;
      if (!fn) {
        ref = ['5 minutes', options], options = ref[0], fn = ref[1];
      }
      if (typeof options === 'string') {
        options = {
          age: options
        };
      }
      if (typeof options.age === 'string') {
        ref1 = options.age.split(' '), age = ref1[0], type = ref1[1];
        age = parseInt(age, 10);
        switch (type) {
          case 'minute':
          case 'minutes':
            age *= 60;
            break;
          case 'hour':
          case 'hours':
            age *= 3600;
            break;
          case 'day':
          case 'days':
            age *= 86400;
            break;
          case 'week':
          case 'weeks':
            age *= 604800;
        }
        options.age = age;
      }
      return function(req, res, next) {
        var cval, fetch, fields, host, i, k, key, len, protocol, query, sval, url, url_noquery, v;
        fetch = function(callback) {
          if (fn.length === 1) {
            return fn(callback);
          } else {
            return fn(req, res, callback);
          }
        };
        if (options.headers == null) {
          options.headers = {};
        }
        res.set(options.headers);
        if (config.disabled) {
          return fetch(function(d) {
            return res.send(d);
          });
        }
        if (req.method === 'POST') {
          return fetch(function(d) {
            return res.send(d);
          });
        }
        if (req.query._) {
          return fetch(function(d) {
            return res.send(d);
          });
        }
        protocol = req.protocol;
        host = req.get('host');
        url = req.originalUrl;
        url_noquery = req._parsedUrl.pathname;
        key = protocol + "://" + host + url_noquery;
        if (options.query == null) {
          options.query = options.qs;
        }
        if (options.query == null) {
          options.query = '*';
        }
        if (typeof options.query === 'string') {
          options.query = options.query.split(',');
        }
        if (typeof options.query === 'boolean') {
          if (options.query) {
            options.query = '*';
          } else {
            options.query = null;
          }
        }
        if (options.query === null) {
          options.query = [];
        }
        if (indexOf.call(options.query, '*') >= 0) {
          key = protocol + "://" + host + url;
        } else {
          fields = options.query.sort();
          if (fields.length > 0) {
            query = [];
            for (i = 0, len = fields.length; i < len; i++) {
              k = fields[i];
              v = req.query[k];
              if (v) {
                query.push(k + "=" + v);
              }
            }
            if (query.length > 0) {
              key = protocol + "://" + host + url_noquery + "?" + (query.join('&'));
            }
          }
        }
        if (options.age === 0) {
          cval = 'private, max-age=0, no-cache, no-store, must-revalidate';
          sval = 'max-age=0';
        } else {
          cval = "public, max-age=" + (Math.min(options.age, 300)) + ", must-revalidate";
          sval = "max-age=" + options.age;
        }
        res.set('Cache-Control', cval);
        res.set('Surrogate-Control', sval);
        res.set('Surrogate-Key', host + " " + key);
        return cache.get(key, function(err, value) {
          if (value) {
            res.set('Dobi-Cache', 'HIT');
            return res.send(value);
          } else {
            res.set('Dobi-Cache', 'MISS');
            return fetch(function(data) {
              return cache.set(key, data, options.age, function(err) {
                return res.send(data);
              });
            });
          }
        });
      };
    };
  };

}).call(this);
